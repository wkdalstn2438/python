# ì¢Œí‘œ ë³€í™˜ ìœ í‹¸
def algebra_to_index(pos: str):
    file = pos[0].lower()
    rank = int(pos[1])
    x = ord(file) - ord('a')
    y = rank - 1
    return x, y

def index_to_algebra(x: int, y: int):
    return f"{chr(ord('a') + x)}{y + 1}"

# 3ê°œ
# í”„ë¡œëª¨ì…˜(í°ì´ ëê¹Œì§€ ê°™ì„ë•Œ í‚¹ ì œì™¸ ì›í•˜ëŠ” ê¸°ë¬¼ë¡œ ë³€ê²½)
# ìºìŠ¬ë§(ì™• ë£©ì˜ ìœ„ì¹˜ë¥¼ ë°”ê¿ˆ)
# ì•™íŒŒìƒ(ìƒëŒ€í°ì„ ë¨¹ìœ¼ë©´ì„œ ëŒ€ê° ì „ì§„)
class Piece:
    def __init__(self, color):
        self.color = color

    def symbol(self):
        raise NotImplementedError

    def valid_moves(self, board, x, y):
        raise NotImplementedError


class King(Piece):
    def symbol(self):
        return 'K' if self.color == 'white' else 'k'

    def valid_moves(self, board, x, y):
        directions = [(-1, -1), (-1, 0), (-1, 1),
                      (0,  -1),          (0,  1),
                      (1,  -1), (1,  0), (1,  1)]
        moves = []
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if board.in_bounds(nx, ny):
                target = board.grid[nx][ny]
                if target is None or target.color != self.color:
                    moves.append((nx, ny))
        return moves


class Queen(Piece):
    def symbol(self):
        return 'Q' if self.color == 'white' else 'q'

    def valid_moves(self, board, x, y):
        moves = []
        directions = [  # ì´ 8ë°©í–¥
            (-1, 0), (1, 0), (0, -1), (0, 1),       # ìƒí•˜ì¢Œìš°
            (-1, -1), (-1, 1), (1, -1), (1, 1)      # ëŒ€ê°ì„ 
        ]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            while board.in_bounds(nx, ny):
                target = board.grid[nx][ny]
                if target is None:
                    moves.append((nx, ny))
                elif target.color != self.color:
                    moves.append((nx, ny))
                    break
                else:
                    break
                nx += dx
                ny += dy

        return moves


class Rook(Piece):
    def symbol(self):
        return 'R' if self.color == 'white' else 'r'
    # ì¡°ê±´ 1: ìƒëŒ€ê¸°ë¬¼ì´ ìˆìœ¼ë©´ ê·¸ ìœ„ì¹˜ê¹Œì§€ë§Œ ì´ë™ ê°€ëŠ¥
    # ì¡°ê±´ 2: ìš°ë¦¬íŒ€ ê¸°ë¬¼ì´ ìˆìœ¼ë©´ ê·¸ ì•ê¹Œì§€ë§Œ ì´ë™ ê°€ëŠ¥
    def valid_moves(self, board, x, y):
        moves = []
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ì¢Œ, ìš°, í•˜, ìƒ

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            while board.in_bounds(nx, ny):
                target = board.grid[nx][ny]
                if target is None:
                    moves.append((nx, ny))
                elif target.color != self.color:
                    moves.append((nx, ny))
                    break  # ìƒëŒ€ ê¸°ë¬¼ì€ ì¡ì„ ìˆ˜ ìˆì§€ë§Œ ê·¸ ì´í›„ëŠ” ëª» ê°
                else:
                    break  # ì•„êµ° ê¸°ë¬¼ ìˆìœ¼ë©´ ê±°ê¸°ì„œ ë©ˆì¶¤
                nx += dx
                ny += dy

        return moves


class Bishop(Piece):
    def symbol(self):
        return 'B' if self.color == 'white' else 'b'

    def valid_moves(self, board, x, y):
        moves = []
        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]  # ì¢Œí•˜, ì¢Œìƒ, ìš°í•˜, ìš°ìƒ

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            while board.in_bounds(nx, ny):
                target = board.grid[nx][ny]
                if target is None:
                    moves.append((nx, ny))
                elif target.color != self.color:
                    moves.append((nx, ny))
                    break  # ì  ê¸°ë¬¼ ìˆìœ¼ë©´ ê±°ê¸°ê¹Œì§€ ì´ë™í•˜ê³  ì¢…ë£Œ
                else:
                    break  # ì•„êµ° ê¸°ë¬¼ì´ë©´ ë§‰í˜
                nx += dx
                ny += dy

        return moves


class Knight(Piece):
    def symbol(self):
        return 'N' if self.color == 'white' else 'n'
# í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì´ë™í• ìˆ˜ìˆëŠ” ì¹¸[ë¦¬ìŠ¤íŠ¸]ë¥¼ ë„˜ê²¨ì£¼ëŠ” í•¨ìˆ˜
    def valid_moves(self, board, x, y):
        moves = []
        directions = [
            (-2, -1), (-2, 1),
            (-1, -2), (-1, 2),
            (1, -2),  (1, 2),
            (2, -1),  (2, 1)
        ]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if board.in_bounds(nx, ny):
                target = board.grid[nx][ny]
                if target is None or target.color != self.color:
                    moves.append((nx, ny))

        return moves


class Pawn(Piece):
    def symbol(self):
        return 'P' if self.color == 'white' else 'p'

    def valid_moves(self, board, x, y):
        moves = []
        direction = 1 if self.color == 'white' else -1
        start_row = 1 if self.color == 'white' else 6

        # í•œ ì¹¸ ì „ì§„
        if board.in_bounds(x, y + direction) and board.grid[x][y + direction] is None:
            moves.append((x, y + direction))

            # ì²« ìˆ˜ì¼ ë•Œ ë‘ ì¹¸ ì „ì§„
            if y == start_row and board.grid[x][y + 2 * direction] is None:
                moves.append((x, y + 2 * direction))

        # ëŒ€ê°ì„  ê³µê²©
        for dx in [-1, 1]:
            nx, ny = x + dx, y + direction
            if board.in_bounds(nx, ny):
                target = board.grid[nx][ny]
                if target and target.color != self.color:
                    moves.append((nx, ny))

        return moves



class Board:
    def __init__(self):
        self.grid = [[None for _ in range(8)] for _ in range(8)]
        self.setup()

    def setup(self):
        # ê¸°ë³¸ ê¸°ë¬¼ ìˆœì„œ
        piece_order = [Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook]

        # 1, 8ë­í¬: ë°±ê³¼ í‘ ê¸°ë¬¼ ë°°ì¹˜
        for x, piece_cls in enumerate(piece_order):
            self.grid[x][0] = piece_cls('white')  # 1 rank
            self.grid[x][7] = piece_cls('black')  # 8 rank

        # 2, 7ë­í¬: í° ë°°ì¹˜
        for x in range(8):
            self.grid[x][1] = Pawn('white')  # 2 rank
            self.grid[x][6] = Pawn('black')  # 7 rank

    def display(self):
        print("  a b c d e f g h")
        for y in reversed(range(8)):
            row = f"{y+1} "
            for x in range(8):
                piece = self.grid[x][y]
                row += piece.symbol() if piece else '.'
                row += ' '
            print(row)
        print()

    def in_bounds(self, x, y):
        return 0 <= x < 8 and 0 <= y < 8


class Game:
    def __init__(self):
        self.board = Board()
        self.turn = 'white'
        self.running = True

    def move(self, x1, y1, x2, y2):
        if not self.is_valid_move(x1, y1, x2, y2):
            return

        self.make_move(x1, y1, x2, y2)
        self.check_win(x2, y2)
        self.handle_promotion(x2, y2)
        self.switch_turn()

    def is_valid_move(self, x1, y1, x2, y2):
        if not self.board.in_bounds(x1, y1) or not self.board.in_bounds(x2, y2):
            print("âŒ Invalid coordinates")
            return False

        piece = self.board.grid[x1][y1]
        if not piece:
            print("âŒ No piece at start position")
            return False
        if piece.color != self.turn:
            print("âŒ Not your turn")
            return False

        valid = piece.valid_moves(self.board, x1, y1)
        if (x2, y2) not in valid:
            print("âŒ Invalid move for that piece")
            return False

        return True

    def make_move(self, x1, y1, x2, y2):
        piece = self.board.grid[x1][y1]
        self.board.grid[x2][y2] = piece
        self.board.grid[x1][y1] = None

    def check_win(self, x, y):
        target = self.board.grid[x][y]
        if isinstance(target, King):
            print(f"ğŸ {self.turn} wins! {target.color} King captured.")
            self.running = False

    def handle_promotion(self, x, y):
        piece = self.board.grid[x][y]
        if isinstance(piece, Pawn):
            final_rank = 7 if piece.color == 'white' else 0
            if y == final_rank:
                while True:
                    choice = input("Promote to (Q, R, B, N): ").strip().upper()
                    if choice in ('Q', 'R', 'B', 'N'):
                        break
                    print("âŒ Invalid choice. Choose from Q, R, B, N.")

                promoted = {'Q': Queen, 'R': Rook, 'B': Bishop, 'N': Knight}[choice]
                self.board.grid[x][y] = promoted(piece.color)
                print(f"{self.turn}'s pawn promoted to {choice} at {index_to_algebra(x, y)}!")

    def switch_turn(self):
        self.turn = 'black' if self.turn == 'white' else 'white'


    def start(self):
        while self.running:
            self.board.display()
            print(f"{self.turn}'s turn. (e.g., e2 e4)")
            try:
                user_input = input("Move: ").strip()
                pos1, pos2 = user_input.split()
                x1, y1 = algebra_to_index(pos1)  # e -> 5
                x2, y2 = algebra_to_index(pos2)
                self.move(x1, y1, x2, y2)
            except Exception as e:
                print("âŒ Invalid input format. Use format like 'e2 e4'")


# ì‹¤í–‰
if __name__ == "__main__":
    Game().start()
